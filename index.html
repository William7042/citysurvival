<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Futuristic City Explorer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Arial', sans-serif;
        }
        #gameCanvas {
            display: block;
            background-color: #111;
        }
        #gameUI {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 18px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
        }
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            text-align: center;
            max-width: 80%;
        }
        .minigame-button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 10px 15px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 5px;
        }
        .minigame-button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="gameUI">Money: $<span id="moneyCounter">0</span></div>
    <div id="instructions">
        Controls: Arrow Keys or A/D to move | SPACE to jump | E to interact with NPCs | Complete mini-games to earn money
    </div>

    <script>
        // Get canvas and context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const moneyCounter = document.getElementById('moneyCounter');
        
        // Set canvas size to window size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Game state
        let playerMoney = 0;
        let dialogOpen = false;
        let currentNPC = null;
        let currentDialogText = "";
        let currentTask = null;
        let tasksCompleted = 0;
        let imagesLoaded = 0;
        let totalImages = 11; // Number of city layer images
        let minigameActive = false;
        let currentMinigame = null;
        
        // For drag and drop games
        let dragging = false;
        let draggedItem = null;
        let mouseX = 0;
        let mouseY = 0;

        // Camera position
        const camera = {
            x: 0
        };

        // World bounds - INCREASED SIGNIFICANTLY TO REMOVE BOUNDARIES
        const worldBounds = {
            min: -10000,
            max: 10000
        };

        // Create simple player object
        const player = {
            x: canvas.width / 2 - 25,
            y: canvas.height * 0.75 - 10, // Adjusted to stand on the floor
            width: 50,
            height: 80,
            speed: 5,
            facingRight: true,
            // Add animation properties
            walkCycle: 0,
            walkSpeed: 0.2,
            // Add jump properties
            jumping: false,
            jumpVelocity: 0,
            jumpStrength: -15,
            gravity: 0.8,
            onGround: true,
            // Floor position
            floorY: canvas.height * 0.75 - 10
        };

        // Load city layer images
        const cityLayers = [];
        
        for (let i = 1; i <= 11; i++) {
            const img = new Image();
            img.onload = function() {
                imagesLoaded++;
                // When all images are loaded, create the city layers
                if (imagesLoaded === totalImages) {
                    console.log("All images loaded!");
                }
            };
            img.onerror = function() {
                console.error(`Failed to load image ${i}.png`);
                // Create a placeholder for failed image loads
                createPlaceholderImage(i);
                imagesLoaded++;
            };
            img.src = `${i}.png`;
            
            // Add to city layers with appropriate parallax speed
            cityLayers.push({
                img: img,
                speed: 0.1 + (i * 0.02), // Adjust speed based on layer
                y: 0,
                height: canvas.height
            });
        }

        // Create a placeholder image if loading fails
        function createPlaceholderImage(index) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Create a gradient based on layer index
            const color = `hsl(${200 + index * 5}, 70%, ${10 + index * 5}%)`;
            const gradient = tempCtx.createLinearGradient(0, 0, 0, tempCanvas.height);
            gradient.addColorStop(0, color);
            gradient.addColorStop(1, '#000033');
            
            tempCtx.fillStyle = gradient;
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            // Add some buildings to make it look city-like
            tempCtx.fillStyle = '#111122';
            for (let i = 0; i < 15; i++) {
                const width = 50 + Math.random() * 100;
                const height = 100 + Math.random() * 300;
                const x = i * 120;
                tempCtx.fillRect(x, tempCanvas.height - height, width, height);
                
                // Add windows
                tempCtx.fillStyle = '#ffff99';
                for (let j = 0; j < 5; j++) {
                    for (let k = 0; k < 3; k++) {
                        if (Math.random() > 0.3) { // Some windows are dark
                            tempCtx.fillRect(
                                x + 10 + k * 15, 
                                tempCanvas.height - height + 20 + j * 50, 
                                10, 
                                20
                            );
                        }
                    }
                }
                tempCtx.fillStyle = '#111122';
            }
            
            // Set the placeholder as the layer image
            cityLayers[index-1].img = tempCanvas;
        }

        // Mini-games

        // Mechanic: Wire Repair Game
        const wireRepairGame = {
            wires: [],
            targets: [],
            connections: [],
            connectedWires: 0,
            totalWires: 5,
            selectedWire: null,
            completed: false,
            
            // Initialize the game
            init: function() {
                this.wires = [];
                this.targets = [];
                this.connections = [];
                this.connectedWires = 0;
                this.selectedWire = null;
                this.completed = false;
                
                // Create random pairs of wires and targets
                const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff'];
                const startY = canvas.height * 0.3;
                
                for (let i = 0; i < this.totalWires; i++) {
                    // Left side wire
                    this.wires.push({
                        x: canvas.width * 0.3,
                        y: startY + (i * 50),
                        color: colors[i],
                        connected: false,
                        id: i
                    });
                    
                    // Right side target (randomized order)
                    this.targets.push({
                        x: canvas.width * 0.7,
                        y: startY + (Math.random() * (this.totalWires - 1) * 50),
                        color: colors[i],
                        connected: false,
                        id: i
                    });
                }
            },
            
            // Handle mouse click
            handleClick: function(x, y) {
                // Check if clicking on a wire
                for (const wire of this.wires) {
                    if (!wire.connected && 
                        x >= wire.x - 20 && x <= wire.x + 20 &&
                        y >= wire.y - 10 && y <= wire.y + 10) {
                        this.selectedWire = wire;
                        return;
                    }
                }
                
                // Check if clicking on a target with a selected wire
                if (this.selectedWire) {
                    for (const target of this.targets) {
                        if (!target.connected &&
                            x >= target.x - 20 && x <= target.x + 20 &&
                            y >= target.y - 10 && y <= target.y + 10) {
                            
                            // Connect the wire to the target
                            if (this.selectedWire.id === target.id) {
                                // Correct match
                                this.connections.push({
                                    wireX: this.selectedWire.x,
                                    wireY: this.selectedWire.y,
                                    targetX: target.x,
                                    targetY: target.y,
                                    color: this.selectedWire.color
                                });
                                
                                this.selectedWire.connected = true;
                                target.connected = true;
                                this.connectedWires++;
                                
                                // Check if all wires are connected
                                if (this.connectedWires >= this.totalWires) {
                                    this.completed = true;
                                }
                            }
                            
                            this.selectedWire = null;
                            return;
                        }
                    }
                    
                    // Clicked elsewhere, deselect wire
                    this.selectedWire = null;
                }
            },
            
            // Draw the game
            draw: function() {
                // Draw background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(canvas.width * 0.2, canvas.height * 0.2, canvas.width * 0.6, canvas.height * 0.6);
                
                // Draw title
                ctx.fillStyle = '#ff6600';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText("Repair the Hover-Car Wiring System", canvas.width * 0.5, canvas.height * 0.25);
                
                // Draw instructions
                ctx.fillStyle = '#ffffff';
                ctx.font = '16px Arial';
                ctx.fillText("Connect the matching colored wires by clicking them in sequence", canvas.width * 0.5, canvas.height * 0.28);
                
                // Draw connections
                ctx.lineWidth = 3;
                for (const conn of this.connections) {
                    ctx.strokeStyle = conn.color;
                    ctx.beginPath();
                    ctx.moveTo(conn.wireX, conn.wireY);
                    ctx.lineTo(conn.targetX, conn.targetY);
                    ctx.stroke();
                }
                
                // Draw wires
                for (const wire of this.wires) {
                    ctx.fillStyle = wire.color;
                    ctx.fillRect(wire.x - 20, wire.y - 5, 40, 10);
                    
                    if (wire === this.selectedWire) {
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(wire.x - 22, wire.y - 7, 44, 14);
                    }
                }
                
                // Draw targets
                for (const target of this.targets) {
                    ctx.fillStyle = target.color;
                    ctx.fillRect(target.x - 20, target.y - 5, 40, 10);
                }
                
                // Draw completion message
                if (this.completed) {
                    ctx.fillStyle = '#00ff00';
                    ctx.font = 'bold 24px Arial';
                    ctx.fillText("Wiring System Repaired! Great job!", canvas.width * 0.5, canvas.height * 0.7);
                    
                    // Draw continue button
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(canvas.width * 0.4, canvas.height * 0.75, canvas.width * 0.2, 40);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '18px Arial';
                    ctx.fillText("Continue", canvas.width * 0.5, canvas.height * 0.75 + 25);
                }
            },
            
            // Check if clicked continue button
            checkContinueClick: function(x, y) {
                if (this.completed && 
                    x >= canvas.width * 0.4 && x <= canvas.width * 0.6 &&
                    y >= canvas.height * 0.75 && y <= canvas.height * 0.75 + 40) {
                    return true;
                }
                return false;
            }
        };

        // Hacker: Code Breaking Game
        const codeBreakingGame = {
            code: [],
            guess: [],
            attempts: 0,
            maxAttempts: 8,
            feedback: [],
            colors: ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'],
            codeLength: 4,
            completed: false,
            
            // Initialize the game
            init: function() {
                this.code = [];
                this.guess = [];
                this.attempts = 0;
                this.feedback = [];
                this.completed = false;
                
                // Generate a random code
                for (let i = 0; i < this.codeLength; i++) {
                    this.code.push(Math.floor(Math.random() * this.colors.length));
                    this.guess.push(0); // Default guess
                }
                
                // Initialize feedback array
                for (let i = 0; i < this.maxAttempts; i++) {
                    this.feedback.push({
                        guess: Array(this.codeLength).fill(0),
                        correct: 0,
                        wrongPosition: 0
                    });
                }
            },
            
            // Handle click
            handleClick: function(x, y) {
                if (this.completed) {
                    // Check if clicking continue button
                    if (x >= canvas.width * 0.4 && x <= canvas.width * 0.6 &&
                        y >= canvas.height * 0.8 && y <= canvas.height * 0.8 + 40) {
                        console.log("Code breaking game: continue button clicked!");
                        return true; // Continue
                    }
                    return false;
                }
                
                // Check if clicking on a color selector
                const selectorY = canvas.height * 0.7;
                const width = canvas.width * 0.6 / this.colors.length;
                
                for (let i = 0; i < this.colors.length; i++) {
                    const selectorX = canvas.width * 0.2 + (i * width);
                    
                    if (x >= selectorX && x <= selectorX + width &&
                        y >= selectorY && y <= selectorY + 30) {
                        
                        // Find which guess slot was last selected
                        const activeSlot = this.guess.findIndex(g => g === -1);
                        
                        if (activeSlot >= 0) {
                            this.guess[activeSlot] = i;
                        }
                        
                        return false;
                    }
                }
                
                // Check if clicking on a guess slot
                const slotY = canvas.height * 0.6;
                const slotWidth = canvas.width * 0.4 / this.codeLength;
                
                for (let i = 0; i < this.codeLength; i++) {
                    const slotX = canvas.width * 0.3 + (i * slotWidth);
                    
                    if (x >= slotX && x <= slotX + slotWidth - 10 &&
                        y >= slotY && y <= slotY + 30) {
                        
                        // Select this slot
                        for (let j = 0; j < this.guess.length; j++) {
                            if (this.guess[j] === -1) {
                                this.guess[j] = 0;
                            }
                        }
                        
                        this.guess[i] = -1; // Mark as selected
                        return false;
                    }
                }
                
                // Check if clicking submit button
                if (x >= canvas.width * 0.7 && x <= canvas.width * 0.8 &&
                    y >= canvas.height * 0.6 && y <= canvas.height * 0.6 + 30) {
                    
                    // Make sure no slot is selected
                    if (this.guess.indexOf(-1) === -1) {
                        this.submitGuess();
                    }
                    
                    return false;
                }
                
                return false;
            },
            
            // Submit the current guess
            submitGuess: function() {
                // Count exact matches and color matches
                let correct = 0;
                let wrongPosition = 0;
                
                const codeCopy = [...this.code];
                const guessCopy = [...this.guess];
                
                // First pass: Check for exact matches
                for (let i = 0; i < this.codeLength; i++) {
                    if (guessCopy[i] === codeCopy[i]) {
                        correct++;
                        // Mark as matched
                        codeCopy[i] = -1;
                        guessCopy[i] = -2;
                    }
                }
                
                // Second pass: Check for color matches in wrong positions
                for (let i = 0; i < this.codeLength; i++) {
                    if (guessCopy[i] >= 0) {
                        const colorIndex = codeCopy.indexOf(guessCopy[i]);
                        if (colorIndex !== -1) {
                            wrongPosition++;
                            codeCopy[colorIndex] = -1;
                        }
                    }
                }
                
                // Store the feedback
                this.feedback[this.attempts] = {
                    guess: [...this.guess],
                    correct: correct,
                    wrongPosition: wrongPosition
                };
                
                this.attempts++;
                
                // Check if won
                if (correct === this.codeLength) {
                    this.completed = true;
                } else if (this.attempts >= this.maxAttempts) {
                    // Failed, reveal the code
                    this.completed = true;
                }
            },
            
            // Draw the game
            draw: function() {
                // Draw background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(canvas.width * 0.2, canvas.height * 0.2, canvas.width * 0.6, canvas.height * 0.6);
                
                // Draw title
                ctx.fillStyle = '#00ff00';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText("Hack the Mainframe Security System", canvas.width * 0.5, canvas.height * 0.25);
                
                // Draw instructions
                ctx.fillStyle = '#ffffff';
                ctx.font = '16px Arial';
                ctx.fillText("Guess the security code. Green dots = correct position, Yellow dots = wrong position", canvas.width * 0.5, canvas.height * 0.28);
                
                // Draw previous guesses and feedback
                for (let i = 0; i < this.attempts; i++) {
                    const y = canvas.height * 0.32 + (i * 30);
                    
                    // Draw guess
                    for (let j = 0; j < this.codeLength; j++) {
                        const x = canvas.width * 0.3 + (j * 40);
                        
                        ctx.fillStyle = this.colors[this.feedback[i].guess[j]];
                        ctx.fillRect(x, y, 30, 20);
                    }
                    
                    // Draw feedback
                    for (let j = 0; j < this.feedback[i].correct; j++) {
                        ctx.fillStyle = '#00ff00'; // Correct
                        ctx.beginPath();
                        ctx.arc(canvas.width * 0.6 + (j * 15), y + 10, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    for (let j = 0; j < this.feedback[i].wrongPosition; j++) {
                        ctx.fillStyle = '#ffff00'; // Wrong position
                        ctx.beginPath();
                        ctx.arc(canvas.width * 0.6 + ((this.feedback[i].correct + j) * 15), y + 10, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Draw current guess slots
                const slotY = canvas.height * 0.6;
                const slotWidth = canvas.width * 0.4 / this.codeLength;
                
                for (let i = 0; i < this.codeLength; i++) {
                    const slotX = canvas.width * 0.3 + (i * slotWidth);
                    
                    // Draw slot background
                    ctx.fillStyle = this.guess[i] === -1 ? '#ffffff' : '#333333';
                    ctx.fillRect(slotX, slotY, slotWidth - 10, 30);
                    
                    // Draw selected color
                    if (this.guess[i] >= 0) {
                        ctx.fillStyle = this.colors[this.guess[i]];
                        ctx.fillRect(slotX + 5, slotY + 5, slotWidth - 20, 20);
                    }
                }
                
                // Draw submit button
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(canvas.width * 0.7, canvas.height * 0.6, 100, 30);
                ctx.fillStyle = '#ffffff';
                ctx.font = '16px Arial';
                ctx.fillText("Submit", canvas.width * 0.75, canvas.height * 0.6 + 20);
                
                // Draw color selectors
                const selectorY = canvas.height * 0.7;
                const width = canvas.width * 0.6 / this.colors.length;
                
                for (let i = 0; i < this.colors.length; i++) {
                    const selectorX = canvas.width * 0.2 + (i * width);
                    
                    ctx.fillStyle = this.colors[i];
                    ctx.fillRect(selectorX, selectorY, width, 30);
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(selectorX, selectorY, width, 30);
                }
                
                // Draw completion message
                if (this.completed) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                    ctx.fillRect(canvas.width * 0.3, canvas.height * 0.4, canvas.width * 0.4, canvas.height * 0.2);
                    
                    ctx.fillStyle = this.feedback[this.attempts - 1].correct === this.codeLength ? '#00ff00' : '#ff0000';
                    ctx.font = 'bold 24px Arial';
                    
                    if (this.feedback[this.attempts - 1].correct === this.codeLength) {
                        ctx.fillText("Access Granted!", canvas.width * 0.5, canvas.height * 0.5);
                    } else {
                        ctx.fillText("Access Denied", canvas.width * 0.5, canvas.height * 0.5);
                        
                        // Show the correct code
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '18px Arial';
                        ctx.fillText("The correct code was:", canvas.width * 0.5, canvas.height * 0.55);
                        
                        for (let i = 0; i < this.codeLength; i++) {
                            const x = canvas.width * 0.4 + (i * 40);
                            
                            ctx.fillStyle = this.colors[this.code[i]];
                            ctx.fillRect(x, canvas.height * 0.58, 30, 20);
                        }
                    }
                    
                    // Draw continue button
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(canvas.width * 0.4, canvas.height * 0.8, canvas.width * 0.2, 40);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '18px Arial';
                    ctx.fillText("Continue", canvas.width * 0.5, canvas.height * 0.8 + 25);
                }
            }
        };

        // Vendor: Package Sorting Game
        const packageSortingGame = {
            packages: [],
            destinations: [],
            correctPlacements: 0,
            totalPackages: 6,
            dragging: false,
            draggedPackage: null,
            completed: false,
            
            // Initialize the game
            init: function() {
                this.packages = [];
                this.destinations = [];
                this.correctPlacements = 0;
                this.dragging = false;
                this.draggedPackage = null;
                this.completed = false;
                
                // Create destinations
                const destinations = ['Residential', 'Business', 'Government'];
                const colors = ['#ff9999', '#99ff99', '#9999ff'];
                
                for (let i = 0; i < destinations.length; i++) {
                    this.destinations.push({
                        name: destinations[i],
                        x: canvas.width * (0.3 + (i * 0.2)),
                        y: canvas.height * 0.3,
                        width: 120,
                        height: 150,
                        color: colors[i]
                    });
                }
                
                // Create packages with random destinations
                for (let i = 0; i < this.totalPackages; i++) {
                    const destIndex = Math.floor(Math.random() * destinations.length);
                    
                    this.packages.push({
                        x: canvas.width * 0.25 + (i * 60),
                        y: canvas.height * 0.6,
                        width: 50,
                        height: 50,
                        destination: destinations[destIndex],
                        color: colors[destIndex],
                        placed: false,
                        correctlyPlaced: false
                    });
                }
            },
            
            // Handle mouse down event
            handleMouseDown: function(x, y) {
                // Check if clicking on a package
                for (const pkg of this.packages) {
                    if (!pkg.placed &&
                        x >= pkg.x && x <= pkg.x + pkg.width &&
                        y >= pkg.y && y <= pkg.y + pkg.height) {
                        
                        this.dragging = true;
                        this.draggedPackage = pkg;
                        
                        // Move package to front
                        const index = this.packages.indexOf(pkg);
                        this.packages.splice(index, 1);
                        this.packages.push(pkg);
                        
                        return;
                    }
                }
            },
            
            // Handle mouse move event
            handleMouseMove: function(x, y) {
                if (this.dragging && this.draggedPackage) {
                    this.draggedPackage.x = x - (this.draggedPackage.width / 2);
                    this.draggedPackage.y = y - (this.draggedPackage.height / 2);
                }
            },
            
            // Handle mouse up event
            handleMouseUp: function() {
                if (this.dragging && this.draggedPackage) {
                    // Check if package is over a destination
                    for (const dest of this.destinations) {
                        if (this.draggedPackage.x + this.draggedPackage.width / 2 >= dest.x &&
                            this.draggedPackage.x + this.draggedPackage.width / 2 <= dest.x + dest.width &&
                            this.draggedPackage.y + this.draggedPackage.height / 2 >= dest.y &&
                            this.draggedPackage.y + this.draggedPackage.height / 2 <= dest.y + dest.height) {
                            
                            // Place package at destination
                            this.draggedPackage.placed = true;
                            
                            // Center package in destination
                            this.draggedPackage.x = dest.x + (dest.width / 2) - (this.draggedPackage.width / 2);
                            this.draggedPackage.y = dest.y + (dest.height / 2) - (this.draggedPackage.height / 2);
                            
                            // Check if correct destination
                            if (this.draggedPackage.destination === dest.name) {
                                this.draggedPackage.correctlyPlaced = true;
                                this.correctPlacements++;
                                
                                // Check if all packages are correctly placed
                                if (this.correctPlacements >= this.totalPackages) {
                                    this.completed = true;
                                }
                            }
                            
                            break;
                        }
                    }
                    
                    this.dragging = false;
                    this.draggedPackage = null;
                }
            },
            
            // Draw the game
            draw: function() {
                // Draw background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(canvas.width * 0.2, canvas.height * 0.2, canvas.width * 0.6, canvas.height * 0.6);
                
                // Draw title
                ctx.fillStyle = '#ff00ff';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText("Sort the Packages by Destination", canvas.width * 0.5, canvas.height * 0.25);
                
                // Draw destinations
                for (const dest of this.destinations) {
                    ctx.fillStyle = dest.color;
                    ctx.fillRect(dest.x, dest.y, dest.width, dest.height);
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(dest.x, dest.y, dest.width, dest.height);
                    
                    ctx.fillStyle = '#000000';
                    ctx.font = 'bold 18px Arial';
                    ctx.fillText(dest.name, dest.x + (dest.width / 2), dest.y + 30);
                }
                
                // Draw packages
                for (const pkg of this.packages) {
                    ctx.fillStyle = pkg.color;
                    ctx.fillRect(pkg.x, pkg.y, pkg.width, pkg.height);
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(pkg.x, pkg.y, pkg.width, pkg.height);
                    
                    // Draw destination label
                    ctx.fillStyle = '#000000';
                    ctx.font = '10px Arial';
                    ctx.fillText(pkg.destination, pkg.x + (pkg.width / 2), pkg.y + (pkg.height / 2));
                    
                    // Draw checkmark if correctly placed
                    if (pkg.correctlyPlaced) {
                        ctx.fillStyle = '#00ff00';
                        ctx.font = 'bold 30px Arial';
                        ctx.fillText("✓", pkg.x + (pkg.width / 2), pkg.y + (pkg.height / 2) + 20);
                    }
                }
                
                // Draw completion message
                if (this.completed) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(canvas.width * 0.3, canvas.height * 0.4, canvas.width * 0.4, canvas.height * 0.2);
                    
                    ctx.fillStyle = '#00ff00';
                    ctx.font = 'bold 24px Arial';
                    ctx.fillText("All Packages Sorted! Great job!", canvas.width * 0.5, canvas.height * 0.5);
                    
                    // Draw continue button
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(canvas.width * 0.4, canvas.height * 0.7, canvas.width * 0.2, 40);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '18px Arial';
                    ctx.fillText("Continue", canvas.width * 0.5, canvas.height * 0.7 + 25);
                }
            },
            
            // Check if clicked continue button
            checkContinueClick: function(x, y) {
                if (this.completed && 
                    x >= canvas.width * 0.4 && x <= canvas.width * 0.6 &&
                    y >= canvas.height * 0.7 && y <= canvas.height * 0.7 + 40) {
                    console.log("Package sorting game: continue button clicked!");
                    return true;
                }
                return false;
            }
        };

        // Scientist: Pop The Lock Game
        const popTheLockGame = {
            angle: 0,
            targetAngle: 45,
            targetWidth: 10,
            speed: 2,
            direction: 1,
            successCount: 0,
            requiredSuccess: 5,
            completed: false,
            lives: 3,
            level: 1,
            
            // Initialize the game
            init: function() {
                this.angle = 0;
                this.targetAngle = 45;
                this.targetWidth = 10;
                this.speed = 2;
                this.direction = 1;
                this.successCount = 0;
                this.completed = false;
                this.lives = 3;
                this.level = 1;
                
                // Set random target angle
                this.targetAngle = Math.floor(Math.random() * 320) + 20;
            },
            
            // Update the game
            update: function() {
                // Move the pointer
                this.angle += this.speed * this.direction;
                
                // Clamp angle to 0-360
                if (this.angle >= 360) {
                    this.angle = 0;
                } else if (this.angle < 0) {
                    this.angle = 359;
                }
            },
            
            // Handle click
            handleClick: function(x, y) {
                // Check if game is complete and clicking continue
                if (this.completed) {
                    // Check if clicking on continue button
                    if (x >= canvas.width * 0.4 && x <= canvas.width * 0.6 &&
                        y >= canvas.height * 0.75 && y <= canvas.height * 0.75 + 40) {
                        return true; // Signal to continue
                    }
                    return false;
                }
                
                // Check if click was successful (in target area)
                const targetStart = this.targetAngle - (this.targetWidth / 2);
                const targetEnd = this.targetAngle + (this.targetWidth / 2);
                
                let success = false;
                
                // Check if angle is within target range (accounting for wrapping around 360)
                if (targetStart >= 0 && targetEnd <= 360) {
                    // Normal case
                    success = this.angle >= targetStart && this.angle <= targetEnd;
                } else if (targetStart < 0) {
                    // Target wraps below 0
                    success = (this.angle >= (targetStart + 360) || this.angle <= targetEnd);
                } else if (targetEnd > 360) {
                    // Target wraps above 360
                    success = (this.angle >= targetStart || this.angle <= (targetEnd - 360));
                }
                
                if (success) {
                    // Successful hit
                    this.successCount++;
                    
                    // Increase difficulty
                    this.level++;
                    this.speed += 0.5;
                    this.targetWidth = Math.max(4, this.targetWidth - 1);
                    
                    // Reverse direction sometimes
                    if (Math.random() > 0.5) {
                        this.direction *= -1;
                    }
                    
                    // Set new random target
                    this.targetAngle = Math.floor(Math.random() * 320) + 20;
                    
                    // Check if completed
                    if (this.successCount >= this.requiredSuccess) {
                        this.completed = true;
                    }
                } else {
                    // Failed hit
                    this.lives--;
                    
                    // Check if game over
                    if (this.lives <= 0) {
                        // Game over - still complete the game but give feedback
                        this.completed = true;
                    }
                }
                
                return false;
            },
            
            // Draw the game
            draw: function() {
                // Draw background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(canvas.width * 0.2, canvas.height * 0.2, canvas.width * 0.6, canvas.height * 0.6);
                
                // Draw title
                ctx.fillStyle = '#00ffff';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText("Calibrate the Quantum Lock", canvas.width * 0.5, canvas.height * 0.25);
                
                // Draw instructions
                ctx.fillStyle = '#ffffff';
                ctx.font = '16px Arial';
                ctx.fillText("Click when the pointer aligns with the target zone", canvas.width * 0.5, canvas.height * 0.3);
                
                // Draw level and lives
                ctx.fillText(`Level: ${this.level}   Lives: ${this.lives}   Success: ${this.successCount}/${this.requiredSuccess}`, canvas.width * 0.5, canvas.height * 0.35);
                
                // Draw lock circle
                const centerX = canvas.width * 0.5;
                const centerY = canvas.height * 0.5;
                const radius = canvas.width * 0.15;
                
                // Draw main circle
                ctx.strokeStyle = '#666666';
                ctx.lineWidth = 15;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Draw target area
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 15;
                const targetStart = (this.targetAngle - (this.targetWidth / 2)) * (Math.PI / 180);
                const targetEnd = (this.targetAngle + (this.targetWidth / 2)) * (Math.PI / 180);
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, targetStart, targetEnd);
                ctx.stroke();
                
                // Draw pointer
                const pointerAngle = this.angle * (Math.PI / 180);
                const pointerX = centerX + Math.cos(pointerAngle) * radius;
                const pointerY = centerY + Math.sin(pointerAngle) * radius;
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(pointerX, pointerY);
                ctx.stroke();
                
                // Draw pointer cap
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(pointerX, pointerY, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw completion message
                if (this.completed) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(canvas.width * 0.3, canvas.height * 0.45, canvas.width * 0.4, canvas.height * 0.2);
                    
                    if (this.lives > 0) {
                        ctx.fillStyle = '#00ff00';
                        ctx.font = 'bold 24px Arial';
                        ctx.fillText("Lock Calibrated! Great job!", canvas.width * 0.5, canvas.height * 0.55);
                    } else {
                        ctx.fillStyle = '#ff6666';
                        ctx.font = 'bold 24px Arial';
                        ctx.fillText("Emergency Override Activated", canvas.width * 0.5, canvas.height * 0.55);
                    }
                    
                    // Draw continue button
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(canvas.width * 0.4, canvas.height * 0.75, canvas.width * 0.2, 40);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '18px Arial';
                    ctx.fillText("Continue", canvas.width * 0.5, canvas.height * 0.75 + 25);
                }
            },
            
            // Check if clicked continue button
            checkContinueClick: function(x, y) {
                if (this.completed && 
                    x >= canvas.width * 0.4 && x <= canvas.width * 0.6 &&
                    y >= canvas.height * 0.75 && y <= canvas.height * 0.75 + 40) {
                    return true;
                }
                return false;
            }
        };

        // Trader: Item Valuation Game
        const itemValuationGame = {
            items: [],
            totalItems: 5,
            currentItem: 0,
            guessValue: 50,
            completed: false,
            score: 0,
            
            // Initialize the game
            init: function() {
                this.items = [];
                this.currentItem = 0;
                this.guessValue = 50;
                this.completed = false;
                this.score = 0;
                
                // Create random items
                const itemNames = [
                    "Ancient Nano-Tech", "Quantum Crystal", "Holographic Memory Core",
                    "Fusion Battery", "Neural Interface", "Time Displacement Coil",
                    "Antimatter Container", "Bio-synthetic Organ", "Gravity Manipulator"
                ];
                
                for (let i = 0; i < this.totalItems; i++) {
                    // Get random item name
                    const nameIndex = Math.floor(Math.random() * itemNames.length);
                    const name = itemNames[nameIndex];
                    itemNames.splice(nameIndex, 1); // Remove used name
                    
                    // Random value between 10 and 90
                    const value = 10 + Math.floor(Math.random() * 81);
                    
                    this.items.push({
                        name: name,
                        value: value,
                        guessed: false,
                        playerGuess: 0,
                        points: 0
                    });
                }
            },
            
            // Handle click
            handleClick: function(x, y) {
                // Check if game is complete and clicking continue
                if (this.completed && 
                    x >= canvas.width * 0.4 && x <= canvas.width * 0.6 &&
                    y >= canvas.height * 0.8 && y <= canvas.height * 0.8 + 40) {
                    return true;
                }
                
                // Check if all items have been valued
                if (this.currentItem >= this.totalItems) {
                    this.completed = true;
                    return false;
                }
                
                // Check if clicking on slider
                if (y >= canvas.height * 0.6 - 10 && y <= canvas.height * 0.6 + 10) {
                    if (x >= canvas.width * 0.3 && x <= canvas.width * 0.7) {
                        // Update guess value based on position
                        this.guessValue = ((x - canvas.width * 0.3) / (canvas.width * 0.4)) * 100;
                        this.guessValue = Math.round(this.guessValue);
                        return false;
                    }
                }
                
                // Check if clicking submit button
                if (x >= canvas.width * 0.4 && x <= canvas.width * 0.6 &&
                    y >= canvas.height * 0.7 && y <= canvas.height * 0.7 + 40) {
                    
                    // Submit guess
                    this.submitGuess();
                    return false;
                }
                
                return false;
            },
            
            // Submit current guess
            submitGuess: function() {
                const item = this.items[this.currentItem];
                item.guessed = true;
                item.playerGuess = this.guessValue;
                
                // Calculate points based on how close the guess was
                const diff = Math.abs(item.value - item.playerGuess);
                if (diff <= 5) {
                    item.points = 20; // Very close
                } else if (diff <= 15) {
                    item.points = 10; // Somewhat close
                } else if (diff <= 30) {
                    item.points = 5; // Not too far
                } else {
                    item.points = 0; // Way off
                }
                
                this.score += item.points;
                this.currentItem++;
                
                // Reset guess for next item
                this.guessValue = 50;
                
                // Check if all items have been valued
                if (this.currentItem >= this.totalItems) {
                    this.completed = true;
                }
            },
            
            // Draw the game
            draw: function() {
                // Draw background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(canvas.width * 0.2, canvas.height * 0.2, canvas.width * 0.6, canvas.height * 0.6);
                
                // Draw title
                ctx.fillStyle = '#ffcc00';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText("Appraise the Rare Items", canvas.width * 0.5, canvas.height * 0.25);
                
                // Draw instructions
                ctx.fillStyle = '#ffffff';
                ctx.font = '16px Arial';
                ctx.fillText("Drag the slider to estimate the value of each item", canvas.width * 0.5, canvas.height * 0.3);
                
                // If all items have been valued, show results
                if (this.completed) {
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '18px Arial';
                    ctx.fillText("Final Results:", canvas.width * 0.5, canvas.height * 0.35);
                    
                    // Draw item results
                    for (let i = 0; i < this.totalItems; i++) {
                        const item = this.items[i];
                        const y = canvas.height * 0.4 + (i * 40);
                        
                        ctx.fillStyle = '#ffffff';
                        ctx.textAlign = 'left';
                        ctx.fillText(item.name, canvas.width * 0.25, y);
                        
                        ctx.textAlign = 'center';
                        ctx.fillText(`Your guess: ${item.playerGuess}`, canvas.width * 0.5, y);
                        
                        ctx.textAlign = 'right';
                        ctx.fillText(`Actual: ${item.value}`, canvas.width * 0.75, y);
                    }
                    
                    // Draw total score
                    ctx.fillStyle = '#ffcc00';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Total Score: ${this.score} / 100`, canvas.width * 0.5, canvas.height * 0.7);
                    
                    // Draw continue button
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(canvas.width * 0.4, canvas.height * 0.8, canvas.width * 0.2, 40);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '18px Arial';
                    ctx.fillText("Continue", canvas.width * 0.5, canvas.height * 0.8 + 25);
                    
                    return;
                }
                
                // Draw current item
                if (this.currentItem < this.totalItems) {
                    const item = this.items[this.currentItem];
                    
                    // Draw item name
                    ctx.fillStyle = '#ffcc00';
                    ctx.font = 'bold 22px Arial';
                    ctx.fillText(item.name, canvas.width * 0.5, canvas.height * 0.4);
                    
                    // Draw item "image" (simple shape)
                    ctx.fillStyle = '#ffcc00';
                    ctx.beginPath();
                    ctx.moveTo(canvas.width * 0.5, canvas.height * 0.45);
                    ctx.lineTo(canvas.width * 0.55, canvas.height * 0.5);
                    ctx.lineTo(canvas.width * 0.5, canvas.height * 0.55);
                    ctx.lineTo(canvas.width * 0.45, canvas.height * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Draw value slider
                    ctx.fillStyle = '#333333';
                    ctx.fillRect(canvas.width * 0.3, canvas.height * 0.6 - 5, canvas.width * 0.4, 10);
                    
                    // Draw value markers
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    
                    for (let i = 0; i <= 10; i++) {
                        const x = canvas.width * 0.3 + (canvas.width * 0.4 * (i / 10));
                        ctx.fillRect(x, canvas.height * 0.6 - 10, 2, 20);
                        ctx.fillText(i * 10, x, canvas.height * 0.6 + 20);
                    }
                    
                    // Draw slider position
                    const sliderX = canvas.width * 0.3 + (canvas.width * 0.4 * (this.guessValue / 100));
                    ctx.fillStyle = '#ffcc00';
                    ctx.beginPath();
                    ctx.arc(sliderX, canvas.height * 0.6, 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw current guess value
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '18px Arial';
                    ctx.fillText(`Your estimate: ${this.guessValue}`, canvas.width * 0.5, canvas.height * 0.65);
                    
                    // Draw submit button
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(canvas.width * 0.4, canvas.height * 0.7, canvas.width * 0.2, 40);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '18px Arial';
                    ctx.fillText("Submit", canvas.width * 0.5, canvas.height * 0.7 + 25);
                }
            }
        };

        // Engineer: Circuit Connection Game
        const circuitConnectionGame = {
            nodes: [],
            connections: [],
            selectedNode: null,
            completedCircuits: 0,
            totalCircuits: 3,
            completed: false,
            
            // Initialize the game
            init: function() {
                this.nodes = [];
                this.connections = [];
                this.selectedNode = null;
                this.completedCircuits = 0;
                this.completed = false;
                
                // Create power sources
                for (let i = 0; i < this.totalCircuits; i++) {
                    this.nodes.push({
                        type: 'source',
                        x: canvas.width * 0.3,
                        y: canvas.height * (0.3 + (i * 0.15)),
                        radius: 15,
                        color: '#cc00ff',
                        connected: false,
                        circuit: i
                    });
                }
                
                // Create targets
                for (let i = 0; i < this.totalCircuits; i++) {
                    this.nodes.push({
                        type: 'target',
                        x: canvas.width * 0.7,
                        y: canvas.height * (0.3 + ((Math.random() * this.totalCircuits) * 0.15)),
                        radius: 15,
                        color: '#4488ff',
                        connected: false,
                        circuit: i
                    });
                }
                
                // Create obstacles/junction points
                for (let i = 0; i < 5; i++) {
                    this.nodes.push({
                        type: 'junction',
                        x: canvas.width * (0.4 + (Math.random() * 0.2)),
                        y: canvas.height * (0.3 + (Math.random() * 0.45)),
                        radius: 8,
                        color: '#ffffff',
                        connected: false,
                        circuit: -1
                    });
                }
            },
            
            // Handle click
            handleClick: function(x, y) {
                // Check if game is completed and clicking continue
                if (this.completed && 
                    x >= canvas.width * 0.4 && x <= canvas.width * 0.6 &&
                    y >= canvas.height * 0.75 && y <= canvas.height * 0.75 + 40) {
                    return true;
                }
                
                // Check if clicking on a node
                for (const node of this.nodes) {
                    const dx = x - node.x;
                    const dy = y - node.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= node.radius) {
                        // If no node is selected, select this one
                        if (!this.selectedNode) {
                            // Can only select sources or already connected junctions
                            if (node.type === 'source' || (node.type === 'junction' && node.connected)) {
                                this.selectedNode = node;
                            }
                        } else {
                            // Trying to connect to another node
                            
                            // Can't connect to self
                            if (node === this.selectedNode) {
                                this.selectedNode = null;
                                return false;
                            }
                            
                            // Check if valid connection
                            if (this.isValidConnection(this.selectedNode, node)) {
                                // Create connection
                                this.connections.push({
                                    from: this.selectedNode,
                                    to: node,
                                    color: this.selectedNode.circuit >= 0 ? this.selectedNode.color : '#ffffff'
                                });
                                
                                // Mark target node as connected
                                node.connected = true;
                                
                                // If target is a junction, it inherits the circuit of the source
                                if (node.type === 'junction' && node.circuit === -1) {
                                    node.circuit = this.selectedNode.circuit;
                                    node.color = this.selectedNode.color;
                                }
                                
                                // Check if the target is a target node with matching circuit
                                if (node.type === 'target' && node.circuit === this.selectedNode.circuit) {
                                    this.completedCircuits++;
                                    
                                    // Check if all circuits are complete
                                    if (this.completedCircuits >= this.totalCircuits) {
                                        this.completed = true;
                                    }
                                }
                                
                                // Select the new node for chaining connections
                                this.selectedNode = node;
                            } else {
                                // Invalid connection, deselect
                                this.selectedNode = null;
                            }
                        }
                        
                        return false;
                    }
                }
                
                // Clicked elsewhere, deselect
                this.selectedNode = null;
                return false;
            },
            
            // Check if connection is valid
            isValidConnection: function(from, to) {
                // Can't connect to already connected target
                if (to.type === 'target' && to.connected) {
                    return false;
                }
                
                // Check if there's already a connection between these nodes
                for (const conn of this.connections) {
                    if ((conn.from === from && conn.to === to) ||
                        (conn.from === to && conn.to === from)) {
                        return false;
                    }
                }
                
                // If connecting from a source, can only connect to junctions or matching targets
                if (from.type === 'source') {
                    return to.type === 'junction' || (to.type === 'target' && to.circuit === from.circuit);
                }
                
                // If connecting from a junction, can connect to other junctions or matching targets
                if (from.type === 'junction') {
                    if (to.type === 'junction') {
                        return true;
                    }
                    
                    if (to.type === 'target') {
                        return to.circuit === from.circuit;
                    }
                    
                    return false;
                }
                
                // Can't connect from a target
                return false;
            },
            
            // Draw the game
            draw: function() {
                // Draw background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(canvas.width * 0.2, canvas.height * 0.2, canvas.width * 0.6, canvas.height * 0.6);
                
                // Draw title
                ctx.fillStyle = '#cc00ff';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText("Recalibrate the City Power Grid", canvas.width * 0.5, canvas.height * 0.25);
                
                // Draw instructions
                ctx.fillStyle = '#ffffff';
                ctx.font = '16px Arial';
                ctx.fillText("Connect power sources to matching targets", canvas.width * 0.5, canvas.height * 0.28);
                ctx.fillText("Use junction points to route around obstacles", canvas.width * 0.5, canvas.height * 0.31);
                
                // Draw connections
                for (const conn of this.connections) {
                    ctx.strokeStyle = conn.color;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(conn.from.x, conn.from.y);
                    ctx.lineTo(conn.to.x, conn.to.y);
                    ctx.stroke();
                }
                
                // Draw nodes
                for (const node of this.nodes) {
                    // Draw circle
                    ctx.fillStyle = node.color;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Draw node type label
                    if (node.type === 'source') {
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText("S" + node.circuit, node.x, node.y + 4);
                    } else if (node.type === 'target') {
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText("T" + node.circuit, node.x, node.y + 4);
                    }
                    
                    // Highlight selected node
                    if (node === this.selectedNode) {
                        ctx.strokeStyle = '#ffff00';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, node.radius + 5, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
                
                // Draw completion message
                if (this.completed) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(canvas.width * 0.3, canvas.height * 0.4, canvas.width * 0.4, canvas.height * 0.2);
                    
                    ctx.fillStyle = '#00ff00';
                    ctx.font = 'bold 24px Arial';
                    ctx.fillText("Power Grid Calibrated! Success!", canvas.width * 0.5, canvas.height * 0.5);
                    
                    // Draw continue button
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(canvas.width * 0.4, canvas.height * 0.75, canvas.width * 0.2, 40);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '18px Arial';
                    ctx.fillText("Continue", canvas.width * 0.5, canvas.height * 0.75 + 25);
                }
            }
        };

        // Simple NPCs with tasks - EXTENDED RANGE
        const npcs = [
            {
                id: 'mechanic',
                x: 200,
                y: canvas.height * 0.75 - 10, // Adjusted to stand on the floor
                width: 40,
                height: 70,
                color: '#ff6600',
                name: 'Mechanic',
                dialog: "Hey there! I need help fixing my hover-car. The wiring system is completely messed up. Can you help me repair it for 50 credits?",
                task: {
                    description: "Connect the matching wires to repair the hover-car",
                    minigame: wireRepairGame,
                    reward: 50
                }
            },
            {
                id: 'hacker',
                x: 600,
                y: canvas.height * 0.75 - 10, // Adjusted to stand on the floor
                width: 40,
                height: 70,
                color: '#00ff00',
                name: 'Hacker',
                dialog: "I need access to the mainframe. Can you help me crack the security system? 100 credits if you succeed.",
                task: {
                    description: "Break the code by finding the correct color sequence",
                    minigame: codeBreakingGame,
                    reward: 100
                }
            },
            {
                id: 'vendor',
                x: 1000,
                y: canvas.height * 0.75 - 10, // Adjusted to stand on the floor
                width: 40,
                height: 70,
                color: '#ff00ff',
                name: 'Vendor',
                dialog: "I need to deliver these packages but they're all mixed up. Help me sort them for 80 credits?",
                task: {
                    description: "Sort the packages by dragging them to the correct destinations",
                    minigame: packageSortingGame,
                    reward: 80
                }
            },
            {
                id: 'scientist',
                x: 1400,
                y: canvas.height * 0.75 - 10, // Adjusted to stand on the floor
                width: 40,
                height: 70,
                color: '#00ffff',
                name: 'Scientist',
                dialog: "The quantum lock on my lab is malfunctioning! Help me calibrate it for 150 credits!",
                task: {
                    description: "Click when the spinning pointer aligns with the target zone",
                    minigame: popTheLockGame,
                    reward: 150
                }
            },
            // Added more NPCs beyond the original boundaries
            {
                id: 'trader',
                x: -800,
                y: canvas.height * 0.75 - 10,
                width: 40,
                height: 70,
                color: '#ffcc00',
                name: 'Trader',
                dialog: "I've got rare items from the old world, but I can't remember their values. Help me appraise them for 120 credits!",
                task: {
                    description: "Guess the value of each rare item as accurately as possible",
                    minigame: itemValuationGame,
                    reward: 120
                }
            },
            {
                id: 'engineer',
                x: 2200,
                y: canvas.height * 0.75 - 10,
                width: 40,
                height: 70,
                color: '#cc00ff',
                name: 'Engineer',
                dialog: "The city power grid is unstable! Help me recalibrate the circuits for 200 credits!",
                task: {
                    description: "Connect power sources to their matching targets using junction points",
                    minigame: circuitConnectionGame,
                    reward: 200
                }
            }
        ];

        // Keyboard input setup
        const keys = {};
        
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            // Jump when space is pressed and player is on the ground
            if (e.key === ' ' && player.onGround && !minigameActive) {
                player.jumping = true;
                player.onGround = false;
                player.jumpVelocity = player.jumpStrength;
            }
            
            // Interaction key when not in a minigame
            if (e.key === 'e' && !dialogOpen && !minigameActive) {
                checkNPCInteraction();
            }
            
            // Prevent default for arrow keys to avoid page scrolling
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Mouse events for mini-games
        window.addEventListener('mousedown', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            
            if (minigameActive && currentMinigame) {
                if (currentMinigame === packageSortingGame) {
                    currentMinigame.handleMouseDown(mouseX, mouseY);
                } else if (currentMinigame.handleClick) {
                    // Check if clicked continue button
                    const shouldContinue = currentMinigame.handleClick(mouseX, mouseY);
                    if (shouldContinue) {
                        completeMinigame();
                    }
                }
            } else if (dialogOpen && currentTask && currentTask.minigame) {
                // Get dialog dimensions
                const dialogWidth = canvas.width * 0.6;
                const dialogHeight = canvas.height * 0.3;
                const dialogX = canvas.width/2 - dialogWidth/2;
                const dialogY = canvas.height * 0.6;
                
                // Check if clicked on the start minigame button 
                // (positioned at bottom center of dialog)
                if (mouseX >= dialogX + (dialogWidth/2) - 100 && 
                    mouseX <= dialogX + (dialogWidth/2) + 100 &&
                    mouseY >= dialogY + dialogHeight - 50 && 
                    mouseY <= dialogY + dialogHeight - 10) {
                    
                    console.log("Start minigame button clicked!");
                    // Start the minigame
                    startMinigame(currentTask.minigame);
                }
            }
        });
        
        window.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            
            if (minigameActive && currentMinigame && currentMinigame.handleMouseMove) {
                currentMinigame.handleMouseMove(mouseX, mouseY);
            }
        });
        
        window.addEventListener('mouseup', () => {
            if (minigameActive && currentMinigame && currentMinigame.handleMouseUp) {
                currentMinigame.handleMouseUp();
            }
        });
        
        window.addEventListener('click', (e) => {
            if (dialogOpen && currentNPC && !minigameActive) {
                if (!currentTask) {
                    // Accept the task
                    currentTask = {...currentNPC.task};
                    currentDialogText = currentTask.description;
                } else if (currentTask && currentMinigame && currentMinigame.completed) {
                    // Close dialog if minigame is completed
                    dialogOpen = false;
                    currentNPC = null;
                    currentTask = null;
                    currentMinigame = null;
                    minigameActive = false;
                }
                
                // Check if clicking on the start minigame button
                const dialogWidth = canvas.width * 0.6;
                const dialogHeight = canvas.height * 0.3;
                const dialogX = canvas.width/2 - dialogWidth/2;
                const dialogY = canvas.height * 0.6;
                
                if (currentTask && currentTask.minigame && !minigameActive) {
                    if (e.clientX >= dialogX + (dialogWidth/2) - 100 && 
                        e.clientX <= dialogX + (dialogWidth/2) + 100 &&
                        e.clientY >= dialogY + dialogHeight - 50 && 
                        e.clientY <= dialogY + dialogHeight - 10) {
                        
                        // Start the minigame
                        startMinigame(currentTask.minigame);
                    }
                }
            }
        });

        function startMinigame(minigame) {
            minigameActive = true;
            currentMinigame = minigame;
            currentMinigame.init();
            console.log("Starting minigame:", currentMinigame);
        }

        function completeMinigame() {
            if (currentTask && currentMinigame && currentMinigame.completed) {
                playerMoney += currentTask.reward;
                moneyCounter.textContent = playerMoney;
                currentDialogText = `Great job! You earned ${currentTask.reward} credits.`;
                tasksCompleted++;
                
                // Mark this NPC's task as completed
                if (currentNPC) {
                    currentNPC.taskCompleted = true;
                }
                
                minigameActive = false;
                console.log("Minigame completed! Returning to dialog.");
            }
        }

        function checkNPCInteraction() {
            if (dialogOpen) return;
            
            for (const npc of npcs) {
                if (npc.taskCompleted) continue; // Skip NPCs whose tasks are already completed
                
                // Check if player is close to this NPC
                const screenX = npc.x - camera.x;
                const dx = Math.abs((player.x + player.width/2) - (screenX + npc.width/2));
                if (dx < 70) {
                    dialogOpen = true;
                    currentNPC = npc;
                    currentDialogText = npc.dialog;
                    break;
                }
            }
        }

        function drawCityLayers() {
            // Draw each city layer with parallax effect
            for (const layer of cityLayers) {
                try {
                    // Calculate parallax offset
                    const layerOffset = -(camera.x * layer.speed) % canvas.width;
                    
                    // Draw main layer
                    ctx.drawImage(layer.img, layerOffset, layer.y, canvas.width, layer.height);
                    
                    // Draw duplicate layer for seamless scrolling
                    if (layerOffset < 0) {
                        ctx.drawImage(layer.img, layerOffset + canvas.width, layer.y, canvas.width, layer.height);
                    } else {
                        ctx.drawImage(layer.img, layerOffset - canvas.width, layer.y, canvas.width, layer.height);
                    }
                } catch (error) {
                    console.error("Error drawing city layer:", error);
                }
            }
        }

        function update() {
            // Apply jumping physics
            if (!player.onGround) {
                player.jumpVelocity += player.gravity;
                player.y += player.jumpVelocity;
                
                // Check if player has landed
                if (player.y >= player.floorY) {
                    player.y = player.floorY;
                    player.onGround = true;
                    player.jumping = false;
                }
            }
            
            // Move player
            let isMoving = false;
            
            if (!minigameActive) {
                if (keys['ArrowLeft'] || keys['a']) {
                    player.facingRight = false;
                    camera.x -= player.speed;
                    isMoving = true;
                } else if (keys['ArrowRight'] || keys['d']) {
                    player.facingRight = true;
                    camera.x += player.speed;
                    isMoving = true;
                }
            }
            
            // Update walking animation
            if (isMoving) {
                player.walkCycle += player.walkSpeed;
                if (player.walkCycle > Math.PI * 2) {
                    player.walkCycle = 0;
                }
            } else {
                player.walkCycle = 0;
            }
            
            // Update active minigame
            if (minigameActive && currentMinigame && currentMinigame.update) {
                currentMinigame.update();
                
                // Check if minigame is completed
                if (currentMinigame.completed) {
                    completeMinigame();
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background city layers
            drawCityLayers();
            
            // Draw floor beneath the player
            const floorY = canvas.height * 0.85;
            ctx.fillStyle = '#333344';
            ctx.fillRect(0, floorY, canvas.width, canvas.height - floorY);
            
            // Add some details to the floor
            ctx.fillStyle = '#222233';
            for (let i = 0; i < canvas.width; i += 100) {
                const offset = (i + camera.x) % 200;
                ctx.fillRect(i - offset, floorY, 50, 2);
            }
            
            // Draw glowing grid lines on the floor
            ctx.strokeStyle = '#4488ff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let i = 0; i < canvas.width; i += 80) {
                const offset = (i + camera.x * 0.5) % 160;
                ctx.moveTo(i - offset, floorY);
                ctx.lineTo(i - offset + 40, canvas.height);
            }
            ctx.stroke();
            
            // Draw NPCs
            for (const npc of npcs) {
                // Only draw NPCs that are within viewport
                const screenX = npc.x - camera.x;
                if (screenX > -npc.width && screenX < canvas.width) {
                    // Draw NPC body
                    ctx.fillStyle = npc.color;
                    ctx.fillRect(screenX, npc.y, npc.width, npc.height);
                    
                    // Draw NPC head
                    ctx.fillStyle = '#f0f0f0';
                    ctx.beginPath();
                    ctx.arc(screenX + npc.width/2, npc.y - 10, 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw NPC name
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(npc.name, screenX + npc.width/2, npc.y - 25);
                    
                    // Indicator for completed tasks
                    if (npc.taskCompleted) {
                        ctx.fillStyle = '#00ff00';
                        ctx.beginPath();
                        ctx.arc(screenX + npc.width/2, npc.y - 40, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Interaction prompt if player is nearby
                    const dx = Math.abs((player.x + player.width/2) - (screenX + npc.width/2));
                    if (dx < 70 && !npc.taskCompleted && !dialogOpen) {
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '12px Arial';
                        ctx.fillText("Press E to talk", screenX + npc.width/2, npc.y - 45);
                    }
                }
            }
            
            // Draw player if not in a minigame
            if (!minigameActive) {
                // Draw player body
                ctx.fillStyle = player.facingRight ? '#3366ff' : '#6699ff';
                ctx.fillRect(player.x, player.y, player.width, player.height);
                
                // Draw player head
                ctx.fillStyle = '#ffcc99';
                ctx.beginPath();
                ctx.arc(player.x + player.width/2, player.y + 15, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw player legs with animation
                ctx.fillStyle = '#2244cc';
                
                // Only animate legs if on ground
                if (player.onGround) {
                    const legOffset = Math.sin(player.walkCycle) * 5;
                    // Left leg
                    ctx.fillRect(
                        player.x + 10, 
                        player.y + player.height - 30 + (player.facingRight ? legOffset : -legOffset), 
                        10, 
                        30
                    );
                    // Right leg
                    ctx.fillRect(
                        player.x + player.width - 20, 
                        player.y + player.height - 30 + (player.facingRight ? -legOffset : legOffset), 
                        10, 
                        30
                    );
                } else {
                    // Jumping legs position
                    ctx.fillRect(player.x + 10, player.y + player.height - 25, 10, 25);
                    ctx.fillRect(player.x + player.width - 20, player.y + player.height - 25, 10, 25);
                }
                
                // Draw jump effect if jumping
                if (!player.onGround) {
                    // Draw small dust/thrust effect below the player
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    for (let i = 0; i < 5; i++) {
                        const size = 3 + Math.random() * 5;
                        const offsetX = Math.random() * player.width;
                        const offsetY = Math.random() * 10 + 5;
                        ctx.beginPath();
                        ctx.arc(
                            player.x + offsetX, 
                            player.y + player.height + offsetY, 
                            size, 
                            0, 
                            Math.PI * 2
                        );
                        ctx.fill();
                    }
                }
            }
            
            // Draw dialog
            if (dialogOpen && currentNPC && !minigameActive) {
                // Draw dialog box
                const dialogWidth = canvas.width * 0.6;
                const dialogHeight = canvas.height * 0.3;
                const dialogX = canvas.width/2 - dialogWidth/2;
                const dialogY = canvas.height * 0.6;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(dialogX, dialogY, dialogWidth, dialogHeight);
                
                ctx.strokeStyle = currentNPC.color;
                ctx.lineWidth = 3;
                ctx.strokeRect(dialogX, dialogY, dialogWidth, dialogHeight);
                
                // Draw NPC name
                ctx.fillStyle = currentNPC.color;
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(currentNPC.name, dialogX + 20, dialogY + 30);
                
                // Draw dialog text
                ctx.fillStyle = '#ffffff';
                ctx.font = '16px Arial';
                
                // Split text into multiple lines if too long
                const maxWidth = dialogWidth - 40;
                const words = currentDialogText.split(' ');
                let line = '';
                let y = dialogY + 60;
                
                for (const word of words) {
                    const testLine = line + word + ' ';
                    const metrics = ctx.measureText(testLine);
                    
                    if (metrics.width > maxWidth) {
                        ctx.fillText(line, dialogX + 20, y);
                        line = word + ' ';
                        y += 25;
                    } else {
                        line = testLine;
                    }
                }
                
                ctx.fillText(line, dialogX + 20, y);
                
                // If task is accepted but not completed, show start button
                if (currentTask && currentTask.minigame && !currentMinigame) {
                    // Draw start button
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(dialogX + (dialogWidth/2) - 100, dialogY + dialogHeight - 50, 200, 40);
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '18px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText("Start Mini-Game", dialogX + (dialogWidth/2), dialogY + dialogHeight - 25);
                }
            }
            
            // Draw active minigame
            if (minigameActive && currentMinigame) {
                currentMinigame.draw();
            }
            
            // Draw mini-map to show position in the expanded world
            const mapWidth = 150;
            const mapHeight = 30;
            const mapX = canvas.width - mapWidth - 10;
            const mapY = 10;
            
            // Draw map background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(mapX, mapY, mapWidth, mapHeight);
            
            // Calculate relative position for the mini-map (scale from world bounds to map width)
            const totalWorldWidth = worldBounds.max - worldBounds.min;
            const playerPosRatio = (camera.x - worldBounds.min) / totalWorldWidth;
            const playerMapX = mapX + (playerPosRatio * mapWidth);
            
            // Draw player position
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(playerMapX, mapY + mapHeight/2, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw NPC positions
            for (const npc of npcs) {
                const npcPosRatio = (npc.x - worldBounds.min) / totalWorldWidth;
                const npcMapX = mapX + (npcPosRatio * mapWidth);
                
                // Only draw if within map bounds
                if (npcMapX >= mapX && npcMapX <= mapX + mapWidth) {
                    ctx.fillStyle = npc.taskCompleted ? '#00ff00' : npc.color;
                    ctx.beginPath();
                    ctx.arc(npcMapX, mapY + mapHeight/2, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw map border
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.strokeRect(mapX, mapY, mapWidth, mapHeight);
            
            // Draw completion message if all tasks are done
            if (tasksCompleted >= npcs.length) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(canvas.width/2 - 200, canvas.height/2 - 100, 400, 200);
                
                ctx.fillStyle = '#00ff00';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText("Congratulations!", canvas.width/2, canvas.height/2 - 50);
                ctx.fillText(`You've completed all tasks`, canvas.width/2, canvas.height/2);
                ctx.fillText(`and earned $${playerMoney}!`, canvas.width/2, canvas.height/2 + 50);
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Update floor position
            player.floorY = canvas.height * 0.75 - 10;
            
            // Update player position
            if (player.onGround) {
                player.y = player.floorY;
            }
            
            // Update NPCs position
            for (const npc of npcs) {
                npc.y = canvas.height * 0.75 - 10;
            }
        });

        // Start the game immediately
        gameLoop();
    </script>
</body>
</html>